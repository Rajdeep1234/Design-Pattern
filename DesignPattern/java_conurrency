
NEW --start--> Runnable ---->(resume/ Waiting)  Blocked

Runnable----Finished---> Terminated

New
Runnable
Blocked(waiting for monitor lock)
Terminated
(specific variation of blocked state)
Waiting --(indefinitely)
Timed_Waiting(for some specific time)


-----------

Thread life cycle

 Main thread --->child thread (independently)
  main --last to finish execution
1.NEW 
!
start
!
2.Runnable-- ready for execution--context switch happens with other threads

3. blocked--->runnable
4. terminated
----
5. waiting(indefinite time)
6. timed waiting (for some specific waiting time)

join ()-- wait until another thread completes execution




======
Semaphore s = new Semaphore(0);
    Semaphore s2 = new Semaphore(1);

the wait operation works only if semaphore = 1, and the signal operation succeeds when semaphore= 0
==============

         //currentThread()
         //positive , long integer
         // long getID()
         // String for identifiction
         //Multiple thread can have same name
         //Default name structure Thread-N
         // String getName()
         setName()
         // priority 1-10
         1-lowest
         10-highest
         gePriority()
         // DO not maintain ref to parent thread
         //for garbage collection o main thread , if holding ref then 
         it will not collected as art of garbage collection
         
         
         //Extend Thread class --override run method
         //implements Runnable, 
         Thread constructor method and pass a runnable(implement) object as its target
         Thread th=new Thread(new OliviaThread())
         OliviaThread implements Runnable
         
         // Runnable is recommended as ---oop suggests to use implementation , multiple implementation is possible and extend is possible
         
         =====================
         
         
         Daemon thread(background) does not prevent the process from terminating if it is running
         
         //make sure threads are not terminating prematurely
         //when the jvm halts , any remaining daemon threads are abandoned
         /// by default non -daemon thread --> turn into a daemon thread
          
         //synchronized--easier, prevens many pitfalls of locks
         //locks--more flexiility
         
         //New thread will inherit daemin ststus from their parent
         /setDaemon() mathod to change status before starting thread
         
         =================Data race=======
         
         two or more concurren thread access the same memory location
         At least one thread is modifying it
         
         read --modify--write
         i) use AtomicInteger
         ii) java object has intrinsic lock
         iii) synchronized keyword
         
         
         locks
         Atomic Variables
         Synchronized methods
         Synchronized statements
         
         
         Synchronized--easier to implement prevents many pitfalls of locks
         
        TO DO
         //trylock
         //read write lock
         
         
         
         
         
         
         