Different types of design patterns
1. Creational design patterns
     1.a: Singleton
     1.b: Factory
     1.c: Builder
2. Structural Design pattern 
     2.a: Adapter
     2.b:Decoraor
     2.c:Proxy
3. Behavioural Design pattern
     3.a:Strategy
     3.b:Observer
     3.c:Iterator
     
 
 
 =========
 3.a: Strategy Design pattern
      
 Algorithm vary independently from the client that uses it. A class behavior or its algorithm can be changed at run time.
 Strategy pattern enables a client code to choose from a family of related but different algorithms 
 and gives it a simple way to choose any of the algorithm in runtime depending on the client context.
 
 
 Driven by Open/closed Principle
This pattern is based on Open/closed principle. We don’t need to modify the context [closed for modification],
 but can choose and add any implementation [open for extension].




For example, in Collections.sort() – we don’t need to change the sort method to achieve different sorting results.
 We can just supply different comparators in runtime.
 
 Strategy VS state design pattern:
 
 
 ------
 interface Strategy {
   public int calculate(int a, int b);
 }
 
 public class AddOperation implements Strategy{
   public int calculate(int a , int b)
   {
       return a+b;
   }
 }
 
 public class Subtract implements Strategy{
   public int calculate(int a , int b)
   {
       return a-b;
   }
 }
 
  public class Multiply implements Strategy{
   public int calculate(int a , int b)
   {
       return a*b;
   }
  }
   public class Division implements Strategy{
   public int calculate(int a , int b)
   {
       return a/b;
   }
  }
   
   
 class Context {
 
 private Strategy strategy;
 
 
 public Context (Strategy strategy)
   {
      this.strategy=strategy;
 
   }
 
 public int executeStrategy(int a, int b)
   {
    return strategy.calculate(a, b);
 
    }
 }
 
 
 public class StrategyxExcutor{
 
    public static void main (String args{})
    {
        Context ctx= new Context(new AddOperation());
           ctx.executeStrategy(1,2);
     
     
        ctx= new Context(new Subtract());
          ctx.executeStrategy(3,4);
        
        ctx= new Context(new Multiply());
            ctx.executeStrategy(4,5);
        
    }
 }
 
 ==============Factory Method==========
 
 A component responsible for wholesale creation of objects , not piecewise
 
 class Point{
 private double x,y;
 private Point(double x, double y) //private construcor , forcing user to create obj using method to avoid constructor overloading
 {
 this.x=x;
 this.y=y;
 
 }
 
 public static  Point newCartesianPoint(double x, double y)
 {
 return new Point(x,y);
 }
 
  public static  Point newPolarPoint(double rho, double theta)
 {
 return new Point(rho*Math.cos(theta),rho*Math.sin(theta));
 }
 
 }
 
 
 public static void main(String args[])
 {
 Point point=Point.newPolarPoint2,3);
 
 }
 
 
 =================Factory=============
 
 //Factory design pattern
abstract class IPhone {
	public IPhone() {
		System.out.println("New IPhone!");
	}
	
	abstract public IPhone getPhone();
}

class ChennaiFactory extends IPhone {

	public IPhone getIPhone() {
		return new IPhone();
	}
	
}

class NoidaFactory extends IPhone {

	public IPhone getIPhone() {
		return new IPhone();
	}
	
}

class PhoneRegister {
	
	public static IPhone getIPhone(String area) {
		if("Noida".equalsIgnoreCase(area)) {
			return new NoidaFactory().getIPhone();
		} else {
			return new ChennaiFactory().getIPhone();
		}
	}
}

public class FactoryExecutor {
	public static void main(String[] args) {
		IPhone iPhone = PhoneRegister.getIPhone("Noida");
		
	}
}
 
 
 
 
 
 ====================Builder======
 
 
 //Builder design pattern
class BankAccount {
	private int id; //mandatory
	private String owner; //mandatory
	private String address;
	private float amount;
	
	public String toString() {
	return "[ id="+id+"\n owner="+owner+"\n address="+address+" amount="+amount+" ]";
	}
}

class BankAccountBuilder {
	private int id; //mandatory
	private String owner; //mandatory
	private String address;
	private float amount;
	BankAccount bankAccount;
	
	BankAccountBuilder(int id, String owner) {
		this.id = id;
		this.owner = owner;
	}
	
	BankAccountBuilder setAddress(String address) {
		this.address = address;
		return BankAccountBuilder;
	}
	BankAccountBuilder setAmount(float amount) {
		this.amount = amount;
		return BankAccountBuilder;
	}
	
	BankAccount build() {
		BankAccount account = new BankAccount();
		account.id = this.id;
		account.owner = this.owner;
		account.address = this.address;
		account.amount = this.amount;
		return account;
	}
}

public class BuilderExecutor {
	public static void main(String[] args) {
		BankAccount bankAccount = new BankAccountBuilder(10001456, "Sai Dipak")
									.setAddress("Bangalore, Karnataka")
									.setAmount(10000.0F)
									.build();
									
		System.out.println(bankAccount);
	}
}
 
 =========================
 
 
 
 
 