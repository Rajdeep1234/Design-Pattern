
============================

1. Logarithm (Complexity Analysis)
2. Graph Traversals (BFS & DFS)
3. Binary Search
4. Sliding Window 
5. Recursion
6. 2 Algorithms (Inverting a binary tree & Reverse a Linked List)
7. Suffix Trees
8. Heaps
9. DP
10. Sorting Algorithms (Quick & Merge)
=======================
Different types of design patterns
1. Creational design patterns
     1.a: Singleton
     1.b: Factory 
          i) abstract factory
          ii) factory method
     1.c: Builder
     1.d prototype
2. Structural Design pattern 
     2.a: Adapter
     2.b:Decorator
     2.c:Proxy
       d.  facade
        e. flyweight
        f. composite
        g. Bridge
3. Behavioural Design pattern
     3.a:Strategy
     3.b:Observer
     3.c:Iterator
        d.state
        e.visitor
        f.Interpretor
        g. command
        h. chain of responsibility
        i. Mediator
        j.Memento
        k. null object
        .template method
 1.a.Singleton
  A class has only one instance and provides global access to this instance.
  //recommended not to use the singleton 
  
  class Singleton
  {
    private static Singleton instance=null;
    
    private Singleton(){};
   
    public static Singleton getInstance ()
    {
        if (null!=instance)
        {
           synchronized(Singleton.class)
           {
           if(instance==null)
             {
              instance= new Singleton();
             }
             
           }
        }
        
        return instance;
    }
  
  }
  
 
 =========
 3.a: Strategy Design pattern
      
 Algorithm vary independently from the client that uses it
 
 ------
 interface Strategy {
   public int calculate(int a, int b);
 }
 
 public class AddOperation implements Strategy{
   public int calculate(int a , int b)
   {
       return a+b;
   }
 }
 
 public class Subtract implements Strategy{
   public int calculate(int a , int b)
   {
       return a-b;
   }
 }
 
  public class Multiply implements Strategy{
   public int calculate(int a , int b)
   {
       return a*b;
   }
  }
   public class Division implements Strategy{
   public int calculate(int a , int b)
   {
       return a/b;
   }
  }
   
   
 class Context {
 
 private Strategy strategy;
 
 
 public Context (Strategy strategy)
   {
      this.strategy=strategy;
 
   }
 
 public int executeStrategy(int a, int b)
   {
    return strategy.calculate(a, b);
 
    }
 }
 
 
 public class StrategyxExcutor{
 
    public static void main (String args{})
    {
        Context ctx= new Context(new AddOperation());
           ctx.executeStrategy(1,2);
     
     
        ctx= new Context(new Subtract());
          ctx.executeStrategy(3,4);
        
        ctx= new Context(new Multiply());
            ctx.executeStrategy(4,5);
        
    }
 }
 
 
 
 
 
