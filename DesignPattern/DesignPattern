Different types of design patterns
1. Creational design patterns
     1.a: Singleton
     1.b: Factory
     1.c: Builder
2. Structural Design pattern 
     2.a: Adapter
     2.b:Decoraor
     2.c:Proxy
3. Behavioural Design pattern
     3.a:Strategy
     3.b:Observer
     3.c:Iterator
     
 
 
 =========
 3.a: Strategy Design pattern
      
 Algorithm vary independently from the client that uses it. A class behavior or its algorithm can be changed at run time.
 Strategy pattern enables a client code to choose from a family of related but different algorithms 
 and gives it a simple way to choose any of the algorithm in runtime depending on the client context.
 
 
 Driven by Open/closed Principle
This pattern is based on Open/closed principle. We don’t need to modify the context [closed for modification],
 but can choose and add any implementation [open for extension].




For example, in Collections.sort() – we don’t need to change the sort method to achieve different sorting results.
 We can just supply different comparators in runtime.
 
 Strategy VS state design pattern:
 
 
 ------
 interface Strategy {
   public int calculate(int a, int b);
 }
 
 public class AddOperation implements Strategy{
   public int calculate(int a , int b)
   {
       return a+b;
   }
 }
 
 public class Subtract implements Strategy{
   public int calculate(int a , int b)
   {
       return a-b;
   }
 }
 
  public class Multiply implements Strategy{
   public int calculate(int a , int b)
   {
       return a*b;
   }
  }
   public class Division implements Strategy{
   public int calculate(int a , int b)
   {
       return a/b;
   }
  }
   
   
 class Context {
 
 private Strategy strategy;
 
 
 public Context (Strategy strategy)
   {
      this.strategy=strategy;
 
   }
 
 public int executeStrategy(int a, int b)
   {
    return strategy.calculate(a, b);
 
    }
 }
 
 
 public class StrategyxExcutor{
 
    public static void main (String args{})
    {
        Context ctx= new Context(new AddOperation());
           ctx.executeStrategy(1,2);
     
     
        ctx= new Context(new Subtract());
          ctx.executeStrategy(3,4);
        
        ctx= new Context(new Multiply());
            ctx.executeStrategy(4,5);
        
    }
 }
 
 
 
 
 