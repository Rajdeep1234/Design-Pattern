
============================

1. Logarithm (Complexity Analysis)
2. Graph Traversals (BFS & DFS)
3. Binary Search
4. Sliding Window 
5. Recursion
6. 2 Algorithms (Inverting a binary tree & Reverse a Linked List)
7. Suffix Trees
8. Heaps
9. DP
10. Sorting Algorithms (Quick & Merge)
=======================
Different types of design patterns
1. Creational design patterns
     1.a: Singleton
     1.b: Factory
     1.c: Builder
2. Structural Design pattern 
     2.a: Adapter
     2.b:Decoraor
     2.c:Proxy
3. Behavioural Design pattern
     3.a:Strategy
     3.b:Observer
     3.c:Iterator
     
 
 
 =========
 3.a: Strategy Design pattern
      
 Algorithm vary independently from the client that uses it
 
 ------
 interface Strategy {
   public int calculate(int a, int b);
 }
 
 public class AddOperation implements Strategy{
   public int calculate(int a , int b)
   {
       return a+b;
   }
 }
 
 public class Subtract implements Strategy{
   public int calculate(int a , int b)
   {
       return a-b;
   }
 }
 
  public class Multiply implements Strategy{
   public int calculate(int a , int b)
   {
       return a*b;
   }
  }
   public class Division implements Strategy{
   public int calculate(int a , int b)
   {
       return a/b;
   }
  }
   
   
 class Context {
 
 private Strategy strategy;
 
 
 public Context (Strategy strategy)
   {
      this.strategy=strategy;
 
   }
 
 public int executeStrategy(int a, int b)
   {
    return strategy.calculate(a, b);
 
    }
 }
 
 
 public class StrategyxExcutor{
 
    public static void main (String args{})
    {
        Context ctx= new Context(new AddOperation());
           ctx.executeStrategy(1,2);
     
     
        ctx= new Context(new Subtract());
          ctx.executeStrategy(3,4);
        
        ctx= new Context(new Multiply());
            ctx.executeStrategy(4,5);
        
    }
 }
 
 
 
 
 
